package com.khorn.terraincontrol.generator.biome.layers;

import com.khorn.terraincontrol.generator.biome.ArraysCache;
import com.khorn.terraincontrol.util.minecraftTypes.DefaultBiome;

public class LayerShore extends Layer {

    public LayerShore(long seed, Layer childLayer) {
        super(seed);
        this.child = childLayer;
    }

    /**
     * Returns a list of integer values generated by this layer. These may be
     * interpreted as temperatures, rainfall amounts, or biomeList[] indices
     * based on the particular GenLayer subclass.
     */
    @Override
    public int[] getInts(ArraysCache cache, int x, int z, int xSize, int zSize) {
        int[] childInts = this.child.getInts(cache, x - 1, z - 1, xSize + 2, zSize + 2);
        int[] thisInts = cache.getArray(xSize * zSize);

        for (int zi = 0; zi < zSize; ++zi) {
            for (int xi = 0; xi < xSize; ++xi) {
                this.initChunkSeed((long) (xi + x), (long) (zi + z));
                int selection = childInts[xi + 1 + (zi + 1) * (xSize + 2)];
                DefaultBiome biome = DefaultBiome.getBiome(selection);
                int northCheck;
                int eastCheck;
                int westCheck;
                int southCheck;

                if (selection == DefaultBiome.MUSHROOM_ISLAND.Id) {
                    northCheck = childInts[xi + 1 + (zi + 1 - 1) * (xSize + 2)];
                    southCheck = childInts[xi + 1 + (zi + 1 + 1) * (xSize + 2)];
                    eastCheck = childInts[xi + 1 + 1 + (zi + 1) * (xSize + 2)];
                    westCheck = childInts[xi + 1 - 1 + (zi + 1) * (xSize + 2)];
                    
                    if (northCheck != DefaultBiome.OCEAN.Id && eastCheck != DefaultBiome.OCEAN.Id && westCheck != DefaultBiome.OCEAN.Id && southCheck != DefaultBiome.OCEAN.Id) {
                        thisInts[xi + zi * xSize] = selection;
                    } else {
                        thisInts[xi + zi * xSize] = DefaultBiome.MUSHROOM_ISLAND_SHORE.Id ;
                    }
                } else if (biome != null && biome.Id == DefaultBiome.JUNGLE.Id) {
//                    } else if (biome != null && biome.getThisClass() == BiomeGenJungle.class) {
                    northCheck = childInts[xi + 1 + (zi + 1 - 1) * (xSize + 2)];
                    southCheck = childInts[xi + 1 + (zi + 1 + 1) * (xSize + 2)];
                    eastCheck = childInts[xi + 1 + 1 + (zi + 1) * (xSize + 2)];
                    westCheck = childInts[xi + 1 - 1 + (zi + 1) * (xSize + 2)];
                    
                    if (this.isForestedOrOcean(northCheck) && this.isForestedOrOcean(eastCheck) && this.isForestedOrOcean(westCheck) && this.isForestedOrOcean(southCheck)) {
                        if (!isOcean(northCheck) && !isOcean(eastCheck) && !isOcean(westCheck) && !isOcean(southCheck)) {
                            thisInts[xi + zi * xSize] = selection;
                        } else {
                            thisInts[xi + zi * xSize] = DefaultBiome.BEACH.Id;
                        }
                    } else {
                        thisInts[xi + zi * xSize] = DefaultBiome.JUNGLE_EDGE.Id;
                    }
                } else if (selection != DefaultBiome.EXTREME_HILLS.Id && selection != DefaultBiome.EXTREME_HILLS_PLUS.Id && selection != DefaultBiome.EXTREME_HILLS_EDGE.Id) {
                    if (biome != null && biome.isSnowEnabled()) {
                        this.checkForShoreCondition(childInts, thisInts, xi, zi, xSize, selection, DefaultBiome.COLD_BEACH.Id);
                    } else if (selection != DefaultBiome.MESA.Id && selection != DefaultBiome.MESA_PLATEAU_FOREST.Id) {
                        if (selection != DefaultBiome.OCEAN.Id && selection != DefaultBiome.DEEP_OCEAN.Id && selection != DefaultBiome.RIVER.Id && selection != DefaultBiome.SWAMPLAND.Id) {
                            northCheck = childInts[xi + 1 + (zi + 1 - 1) * (xSize + 2)];
                            southCheck = childInts[xi + 1 + (zi + 1 + 1) * (xSize + 2)];
                            eastCheck = childInts[xi + 1 + 1 + (zi + 1) * (xSize + 2)];
                            westCheck = childInts[xi + 1 - 1 + (zi + 1) * (xSize + 2)];

                            if (!isOcean(northCheck) && !isOcean(eastCheck) && !isOcean(westCheck) && !isOcean(southCheck)) {
                                thisInts[xi + zi * xSize] = selection;
                            } else {
                                thisInts[xi + zi * xSize] = DefaultBiome.BEACH.Id;
                            }
                        } else {
                            thisInts[xi + zi * xSize] = selection;
                        }
                    } else {
                        northCheck = childInts[xi + 1 + (zi + 1 - 1) * (xSize + 2)];
                        eastCheck = childInts[xi + 1 + 1 + (zi + 1) * (xSize + 2)];
                        westCheck = childInts[xi + 1 - 1 + (zi + 1) * (xSize + 2)];
                        southCheck = childInts[xi + 1 + (zi + 1 + 1) * (xSize + 2)];

                        if (!isOcean(northCheck) && !isOcean(eastCheck) && !isOcean(westCheck) && !isOcean(southCheck)) {
                            if (this.isMesaBiome(northCheck) && this.isMesaBiome(eastCheck) && this.isMesaBiome(westCheck) && this.isMesaBiome(southCheck)) {
                                thisInts[xi + zi * xSize] = selection;
                            } else {
                                thisInts[xi + zi * xSize] = DefaultBiome.DESERT.Id;
                            }
                        } else {
                            thisInts[xi + zi * xSize] = selection;
                        }
                    }
                } else {
                    this.checkForShoreCondition(childInts, thisInts, xi, zi, xSize, selection, DefaultBiome.STONE_BEACH.Id);
                }
            }
        }

        return thisInts;
    }

    private void checkForShoreCondition(int[] parentInts, int[] thisInts, int x, int z, int radius, int currentBiome, int replaceBiome) {
        if (isOcean(currentBiome)) {
            //>>	Center is Ocean
            thisInts[x + z * radius] = currentBiome;
        } else {
            //>>	Center is not ocean
            int northCheck = parentInts[x + 1 + (z + 1 - 1) * (radius + 2)];
            int eastCheck = parentInts[x + 1 + 1 + (z + 1) * (radius + 2)];
            int westCheck = parentInts[x + 1 - 1 + (z + 1) * (radius + 2)];
            int southCheck = parentInts[x + 1 + (z + 1 + 1) * (radius + 2)];

            if (!isOcean(northCheck) && !isOcean(eastCheck) && !isOcean(westCheck) && !isOcean(southCheck)) {
                //>>	No Ocean Present
                thisInts[x + z * radius] = currentBiome;
            } else {
                //>>	
                thisInts[x + z * radius] = replaceBiome;
            }
        }
    }

    private boolean isForestedOrOcean(int biomeId)
    {
//        return BiomeGenBase.getBiomeGenerator(biomeID) != null && BiomeGenBase.getBiomeGenerator(biomeID).getThisClass() == BiomeGenJungle.class ? true : biomeID == BiomeGenBase.jungleEdge.biomeID || biomeID == BiomeGenBase.jungle.biomeID || biomeID == BiomeGenBase.jungleHills.biomeID || biomeID == BiomeGenBase.forest.biomeID || biomeID == BiomeGenBase.taiga.biomeID || isOcean(biomeID);
        return DefaultBiome.getBiome(biomeId) != null && (biomeId == DefaultBiome.JUNGLE.Id || biomeId == DefaultBiome.JUNGLE_EDGE.Id || biomeId == DefaultBiome.JUNGLE_HILLS.Id || biomeId == DefaultBiome.FOREST.Id || biomeId == DefaultBiome.TAIGA.Id || isOcean(biomeId));
    }

    private boolean isMesaBiome(int biomeId)
    {
//        return BiomeGenBase.getBiomeGenerator(BiomeID) != null && BiomeGenBase.getBiomeGenerator(BiomeID) instanceof BiomeGenMesa;
        return DefaultBiome.getBiome(biomeId) != null && biomeId == DefaultBiome.MESA.Id;
    }
}
