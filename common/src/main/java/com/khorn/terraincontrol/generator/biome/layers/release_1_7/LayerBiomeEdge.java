package com.khorn.terraincontrol.generator.biome.layers.release_1_7;

import com.khorn.terraincontrol.generator.biome.ArraysCache;
import com.khorn.terraincontrol.generator.biome.layers.Layer;
import com.khorn.terraincontrol.util.minecraftTypes.DefaultBiome;

import static com.khorn.terraincontrol.generator.biome.layers.release_1_7.LayerR17.compareBiomes;

public class LayerBiomeEdge extends LayerR17
{

    public LayerBiomeEdge(long seed, Layer childLayer)
    {
        super(seed);
        this.child = childLayer;
    }

    /**
     * Returns a list of integer values generated by this layer. These may be
     * interpreted as temperatures, rainfall amounts, or biomeList[] indices
     * based on the particular GenLayer subclass.
     */
    @Override
    public int[] getInts(ArraysCache cache, int x, int z, int xSize, int zSize)
    {
        int[] parentInts = this.child.getInts(cache, x - 1, z - 1, xSize + 2, zSize + 2);
        int[] thisInts = cache.getArray(xSize * zSize);

        for (int zi = 0; zi < zSize; ++zi)
        {
            for (int xi = 0; xi < xSize; ++xi)
            {
                this.initChunkSeed((long) (xi + x), (long) (zi + z));
                int selection = parentInts[xi + 1 + (zi + 1) * (xSize + 2)];

                if (!this.makeEdgeFromTempCategory(parentInts, thisInts, xi, zi, xSize, selection, DefaultBiome.EXTREME_HILLS.Id, DefaultBiome.EXTREME_HILLS_EDGE.Id) && 
                    !this.makeEdgeFromBiome(parentInts, thisInts, xi, zi, xSize, selection, DefaultBiome.MESA_PLATEAU_FOREST.Id, DefaultBiome.MESA.Id) && 
                    !this.makeEdgeFromBiome(parentInts, thisInts, xi, zi, xSize, selection, DefaultBiome.MESA_PLATEAU.Id, DefaultBiome.MESA.Id) && 
                    !this.makeEdgeFromBiome(parentInts, thisInts, xi, zi, xSize, selection, DefaultBiome.MEGA_TAIGA.Id, DefaultBiome.TAIGA.Id))
                {
                    int northCheck;
                    int southCheck;
                    int eastCheck;
                    int westCheck;

                    if (selection == DefaultBiome.DESERT.Id)
                    {
                        northCheck = parentInts[xi + 1 + (zi + 1 - 1) * (xSize + 2)];
                        southCheck = parentInts[xi + 1 + (zi + 1 + 1) * (xSize + 2)];
                        eastCheck = parentInts[xi + 1 + 1 + (zi + 1) * (xSize + 2)];
                        westCheck = parentInts[xi + 1 - 1 + (zi + 1) * (xSize + 2)];

                        if (northCheck != DefaultBiome.ICE_PLAINS.Id && eastCheck != DefaultBiome.ICE_PLAINS.Id && westCheck != DefaultBiome.ICE_PLAINS.Id && southCheck != DefaultBiome.ICE_PLAINS.Id)
                        {
                            thisInts[xi + zi * xSize] = selection;
                        } else
                        {
                            thisInts[xi + zi * xSize] = DefaultBiome.EXTREME_HILLS_PLUS.Id;
                        }
                    } else if (selection == DefaultBiome.SWAMPLAND.Id)
                    {
                        northCheck = parentInts[xi + 1 + (zi + 1 - 1) * (xSize + 2)];
                        southCheck = parentInts[xi + 1 + (zi + 1 + 1) * (xSize + 2)];
                        eastCheck = parentInts[xi + 1 + 1 + (zi + 1) * (xSize + 2)];
                        westCheck = parentInts[xi + 1 - 1 + (zi + 1) * (xSize + 2)];

                        if (northCheck != DefaultBiome.DESERT.Id && eastCheck != DefaultBiome.DESERT.Id && westCheck != DefaultBiome.DESERT.Id && southCheck != DefaultBiome.DESERT.Id && northCheck != DefaultBiome.COLD_TAIGA.Id && eastCheck != DefaultBiome.COLD_TAIGA.Id && westCheck != DefaultBiome.COLD_TAIGA.Id && southCheck != DefaultBiome.COLD_TAIGA.Id && northCheck != DefaultBiome.ICE_PLAINS.Id && eastCheck != DefaultBiome.ICE_PLAINS.Id && westCheck != DefaultBiome.ICE_PLAINS.Id && southCheck != DefaultBiome.ICE_PLAINS.Id)
                        {
                            if (northCheck != DefaultBiome.JUNGLE.Id && southCheck != DefaultBiome.JUNGLE.Id && eastCheck != DefaultBiome.JUNGLE.Id && westCheck != DefaultBiome.JUNGLE.Id)
                            {
                                thisInts[xi + zi * xSize] = selection;
                            } else
                            {
                                thisInts[xi + zi * xSize] = DefaultBiome.JUNGLE_EDGE.Id;
                            }
                        } else
                        {
                            thisInts[xi + zi * xSize] = DefaultBiome.PLAINS.Id;
                        }
                    } else
                    {
                        thisInts[xi + zi * xSize] = selection;
                    }
                }
            }
        }

        return thisInts;
    }

    private boolean makeEdgeFromTempCategory(int[] parentInts, int[] intCache, int x, int z, int radius, int currentBiome, int checkFor, int replaceBiome)
    {
        if (!compareBiomes(currentBiome, checkFor))
        {
            return false;
        } else
        {
            int northCheck = parentInts[x + 1 + (z + 1 - 1) * (radius + 2)];
            int southCheck = parentInts[x + 1 + (z + 1 + 1) * (radius + 2)];
            int eastCheck = parentInts[x + 1 + 1 + (z + 1) * (radius + 2)];
            int westCheck = parentInts[x + 1 - 1 + (z + 1) * (radius + 2)];

            if (this.compareTempCategories(northCheck, checkFor) && this.compareTempCategories(eastCheck, checkFor) && this.compareTempCategories(westCheck, checkFor) && this.compareTempCategories(southCheck, checkFor))
            {
                intCache[x + z * radius] = currentBiome;
            } else
            {
                intCache[x + z * radius] = replaceBiome;
            }
            return true;
        }
    }

    private boolean makeEdgeFromBiome(int[] parentInts, int[] intCache, int x, int z, int radius, int currentBiome, int checkFor, int replaceBiome)
    {
        if (currentBiome != checkFor)
        {
            return false;
        } else
        {
            int northCheck = parentInts[x + 1 + (z + 1 - 1) * (radius + 2)];
            int southCheck = parentInts[x + 1 + (z + 1 + 1) * (radius + 2)];
            int eastCheck = parentInts[x + 1 + 1 + (z + 1) * (radius + 2)];
            int westCheck = parentInts[x + 1 - 1 + (z + 1) * (radius + 2)];

            if (compareBiomes(northCheck, checkFor) && compareBiomes(eastCheck, checkFor) && compareBiomes(westCheck, checkFor) && compareBiomes(southCheck, checkFor))
            {
                intCache[x + z * radius] = currentBiome;
            } else
            {
                intCache[x + z * radius] = replaceBiome;
            }
            return true;
        }
    }

    private boolean compareTempCategories(int biome_A_ID, int biome_B_ID)
    {
        if (compareBiomes(biome_A_ID, biome_B_ID))
        {
            return true;
        } else if (DefaultBiome.getBiome(biome_A_ID) != null && DefaultBiome.getBiome(biome_B_ID) != null)
        {
            DefaultBiome.TempCategory biome_A_TempCategory = DefaultBiome.getBiome(biome_A_ID).getBiomeTemperatureCategory();
            DefaultBiome.TempCategory biome_B_TempCategory = DefaultBiome.getBiome(biome_B_ID).getBiomeTemperatureCategory();
            return biome_A_TempCategory == biome_B_TempCategory || biome_A_TempCategory == DefaultBiome.TempCategory.MEDIUM || biome_B_TempCategory == DefaultBiome.TempCategory.MEDIUM;
        } else
        {
            return false;
        }
    }

}
